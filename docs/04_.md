# Desenvolvimento do Backend: da Estrutura Modular à Integração com IA

## 1. Arquitetura Modular e Refatoração

O desenvolvimento do backend começou com um único arquivo de rotas (`routes.py`) que centralizava todas as responsabilidades, mas rapidamente se mostrou limitado e difícil de manter.

- **Desafio:** O arquivo monolítico misturava carregamento de dados, definição de rotas e lógica de sorteio, tornando a futura integração com a IA confusa e propensa a erros.
- **Decisão:** Adotar uma arquitetura modular padrão Flask, separando claramente responsabilidades.
- **Solução Técnica:**  
  - **Application Factory:** A criação da aplicação Flask foi movida para uma função `create_app()` em `app/__init__.py`, aumentando testabilidade e flexibilidade.  
  - **Blueprints:** As rotas foram organizadas dentro de um `Blueprint` chamado `main`, agrupando funcionalidades relacionadas e facilitando expansão futura.  
  - **Camada de Serviços:** Criada a pasta `app/services/` para abrigar a “inteligência” da aplicação, separando lógica de negócio da lógica web.

---

## 2. Gerenciamento de Dados: O Baralho de Tarot

A fonte de dados das cartas também precisava de estrutura profissional.

- **Desafio:** Manter os 78 cards diretamente no código (`BARALHO = [...]`) era inflexível e poluía a lógica da aplicação.  
- **Decisão:** Mover todos os dados para um arquivo externo `tarrotanime.json`, tornando-os independentes do código.  
- **Solução Técnica:**  
  - Criado `app/services/tarot_service.py` com responsabilidade única de gerenciar as cartas.  
  - Os dados são carregados do JSON uma única vez na inicialização, garantindo alta performance.  
  - **Desafio enfrentado:** `FileNotFoundError` solucionado ajustando o caminho relativo com `os.path.join` da pasta de serviços até `app/data/`.

---

## 3. Integração com a Inteligência Artificial (Gemini)

Nesta etapa, o Oráculo ganhou “voz” por meio da IA.

- **Desafio:** Conectar-se de forma segura e eficiente a um serviço externo para gerar respostas personalizadas.  
- **Decisões e Soluções:**  
  - **Módulo Dedicado:** Criado `app/services/gemini_service.py` para encapsular toda a lógica de comunicação com a API do Google Gemini, garantindo modularidade.  
  - **Segurança da API Key:** A chave foi armazenada em `.env` e carregada via `python-dotenv`; adicionada ao `.gitignore`.  
  - **Engenharia de Prompt:** Prompt detalhado instrui a IA a agir como um “oráculo de tarot místico, sábio e poético”, usando nome e significado da carta sorteada para respostas temáticas e ricas.  
  - **Tratamento de Erros:** Bloco `try...except` captura falhas de conexão ou erros da API, retornando mensagens amigáveis em vez de quebrar a aplicação.  
  - **Desafio enfrentado:** Atualização do modelo de `gemini-pro` para `gemini-1.5-flash-latest` após erro 404 na API.

---

## 4. A API Final: Ponto de Conexão com o Frontend

Com os serviços prontos, `app/main/routes.py` foi simplificado e atua apenas como **orquestrador**:

1. Recebe requisição web do frontend.  
2. Chama `tarot_service` para sortear uma carta.  
3. Chama `gemini_service` para gerar a resposta do Oráculo.  
4. Monta o JSON final e envia de volta para o frontend.

---

**Resultado Final:**  
Backend modular, escalável e seguro, pronto para integração com o frontend, com serviços de tarot e IA separados, tratamento de erros robusto e fluxo de dados consistente.
